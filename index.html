<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Mesh PWA</title>
    
    <!-- PWA 메타 태그 -->
    <meta name="theme-color" content="#4285f4">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Face Mesh PWA">
    <link rel="apple-touch-icon" href="icon.png">
    <link rel="manifest" href="manifest.json">
    
    <!-- MediaPipe 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            min-height: 100vh;
        }
        
        .header {
            background-color: #4285f4;
            color: white;
            width: 100%;
            text-align: center;
            padding: 15px 0;
            margin-bottom: 20px;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
            padding: 0 20px;
            box-sizing: border-box;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            margin-bottom: 20px;
            border-radius: 10px;
            overflow: hidden;
            background-color: black;
        }
        
        #input-video {
            width: 100%;
            display: none;
        }
        
        #output-canvas {
            width: 100%;
            transform: scaleX(-1);
            display: block;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }
        
        .button {
            background-color: #4285f4;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .button:hover {
            background-color: #3367d6;
        }
        
        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .options {
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            width: 100%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .option-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        
        .option-row:last-child {
            border-bottom: none;
        }
        
        .status {
            text-align: center;
            margin: 10px 0;
            font-style: italic;
            color: #666;
        }
        
        /* 효과 선택 버튼 스타일 */
        .effect-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            margin: 10px 0;
        }
        
        .effect-button {
            background-color: white;
            border: 1px solid #4285f4;
            color: #4285f4;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .effect-button.active {
            background-color: #4285f4;
            color: white;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 0 10px;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .button {
                width: 100%;
                margin-bottom: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Face Mesh PWA</h1>
        <p>MediaPipe를 활용한 실시간 얼굴 메시 카메라</p>
    </div>
    
    <div class="container">
        <div class="video-container">
            <video id="input-video" playsinline></video>
            <canvas id="output-canvas"></canvas>
        </div>
        
        <div class="controls">
            <button id="startBtn" class="button">카메라 시작</button>
            <button id="switchBtn" class="button" disabled>카메라 전환</button>
            <button id="captureBtn" class="button" disabled>사진 찍기</button>
        </div>
        
        <div class="effect-buttons">
            <button class="effect-button active" data-effect="mesh">메시</button>
            <button class="effect-button" data-effect="contour">윤곽선</button>
            <button class="effect-button" data-effect="irises">홍채</button>
            <button class="effect-button" data-effect="fun">재미 효과</button>
            <button class="effect-button" data-effect="none">없음</button>
        </div>
        
        <div class="options">
            <div class="option-row">
                <span>메시 밀도</span>
                <select id="meshDensity">
                    <option value="sparse">낮음</option>
                    <option value="medium" selected>중간</option>
                    <option value="dense">높음</option>
                </select>
            </div>
            <div class="option-row">
                <span>메시 색상</span>
                <input type="color" id="meshColor" value="#4285f4">
            </div>
            <div class="option-row">
                <span>메시 두께</span>
                <input type="range" id="meshThickness" min="1" max="5" value="2">
            </div>
        </div>
        
        <p id="status" class="status">카메라를 시작하려면 버튼을 클릭하세요.</p>
    </div>
    
    <script>
        // DOM 요소
        const inputVideo = document.getElementById('input-video');
        const outputCanvas = document.getElementById('output-canvas');
        const ctx = outputCanvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const switchBtn = document.getElementById('switchBtn');
        const captureBtn = document.getElementById('captureBtn');
        const statusText = document.getElementById('status');
        const meshDensity = document.getElementById('meshDensity');
        const meshColor = document.getElementById('meshColor');
        const meshThickness = document.getElementById('meshThickness');
        const effectButtons = document.querySelectorAll('.effect-button');
        
        // 상태 변수
        let faceMesh;
        let camera;
        let currentEffect = 'mesh';
        let facingMode = 'user'; // 기본 전면 카메라
        let detectedFaces = [];
        let isInitialized = false;
        
        // 캔버스 크기 설정
        function setCanvasSize() {
            const devicePixelRatio = window.devicePixelRatio || 1;
            const width = inputVideo.videoWidth || 640;
            const height = inputVideo.videoHeight || 480;
            
            // 디스플레이 크기 설정
            outputCanvas.style.width = '100%';
            outputCanvas.style.height = 'auto';
            
            // 실제 캔버스 해상도 설정 (고해상도)
            outputCanvas.width = width;
            outputCanvas.height = height;
            
            // 고해상도 렌더링을 위한 스케일 조정
            ctx.scale(1, 1);
        }
        
        // MediaPipe FaceMesh 초기화
        function initFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
                }
            });
            
            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            faceMesh.onResults(onResults);
            
            statusText.textContent = 'FaceMesh가 초기화되었습니다.';
            isInitialized = true;
        }
        
        // 카메라 시작 버튼
        startBtn.addEventListener('click', async () => {
            try {
                if (!isInitialized) {
                    initFaceMesh();
                }
                
                // 카메라 접근 요청
                const constraints = {
                    video: {
                        facingMode: facingMode,
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                inputVideo.srcObject = stream;
                
                // MediaPipe 카메라 유틸리티 초기화
                camera = new Camera(inputVideo, {
                    onFrame: async () => {
                        await faceMesh.send({image: inputVideo});
                    },
                    width: 1280,
                    height: 720
                });
                
                await camera.start();
                
                // 버튼 상태 업데이트
                startBtn.disabled = true;
                switchBtn.disabled = false;
                captureBtn.disabled = false;
                
                // 상태 메시지 업데이트
                statusText.textContent = '카메라가 활성화되었습니다. 얼굴을 화면 중앙에 위치시키세요.';
                
            } catch (error) {
                console.error('카메라 접근 에러:', error);
                statusText.textContent = '카메라 접근에 실패했습니다: ' + error.message;
            }
        });
        
        // 카메라 전환 버튼
        switchBtn.addEventListener('click', async () => {
            if (camera) {
                // 카메라 중지
                await camera.stop();
                
                // 현재 스트림 중지
                if (inputVideo.srcObject) {
                    inputVideo.srcObject.getTracks().forEach(track => {
                        track.stop();
                    });
                }
                
                // 카메라 방향 전환
                facingMode = facingMode === 'user' ? 'environment' : 'user';
                
                try {
                    // 새 스트림 가져오기
                    const constraints = {
                        video: {
                            facingMode: facingMode,
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    };
                    
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    inputVideo.srcObject = stream;
                    
                    // 카메라 다시 시작
                    await camera.start();
                    
                    // 상태 메시지 업데이트
                    statusText.textContent = '카메라가 전환되었습니다.';
                    
                } catch (error) {
                    console.error('카메라 전환 에러:', error);
                    statusText.textContent = '카메라 전환에 실패했습니다: ' + error.message;
                }
            }
        });
        
        // 사진 찍기 버튼
        captureBtn.addEventListener('click', () => {
            // 임시 캔버스 생성하여 현재 화면 캡처
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = outputCanvas.width;
            captureCanvas.height = outputCanvas.height;
            const captureCtx = captureCanvas.getContext('2d');
            
            // 현재 화면 복사
            captureCtx.drawImage(outputCanvas, 0, 0);
            
            // 이미지 데이터 URL 생성
            const imageDataURL = captureCanvas.toDataURL('image/png');
            
            // 다운로드 링크 생성 및 클릭
            const link = document.createElement('a');
            link.href = imageDataURL;
            link.download = 'face-mesh-' + new Date().toISOString().replace(/:/g, '-') + '.png';
            link.click();
            
            // 상태 메시지 업데이트
            statusText.textContent = '사진이 저장되었습니다.';
        });
        
        // 효과 버튼 이벤트 리스너
        effectButtons.forEach(button => {
            button.addEventListener('click', () => {
                // 이전 활성 버튼 비활성화
                document.querySelector('.effect-button.active').classList.remove('active');
                
                // 현재 버튼 활성화
                button.classList.add('active');
                
                // 효과 업데이트
                currentEffect = button.dataset.effect;
                
                // 상태 메시지 업데이트
                statusText.textContent = `'${button.textContent}' 효과가 적용되었습니다.`;
            });
        });
        
        // FaceMesh 결과 처리
        function onResults(results) {
            if (!outputCanvas) return;
            
            // 캔버스 크기가 설정되지 않았다면 설정
            if (outputCanvas.width === 0) {
                setCanvasSize();
            }
            
            // 캔버스 지우기
            ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            // 비디오 프레임 그리기
            ctx.save();
            ctx.translate(outputCanvas.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);
            ctx.restore();
            
            // 감지된 얼굴 저장
            detectedFaces = results.multiFaceLandmarks;
            
            // 얼굴이 감지되었을 때만 처리
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                // 각 얼굴에 대해 처리
                for (const landmarks of results.multiFaceLandmarks) {
                    drawFaceMesh(landmarks);
                }
            }
        }
        
        // 얼굴 메시 그리기
        function drawFaceMesh(landmarks) {
            // 현재 설정값 가져오기
            const density = meshDensity.value;
            const color = meshColor.value;
            const thickness = parseInt(meshThickness.value);
            
            switch (currentEffect) {
                case 'mesh':
                    drawMesh(landmarks, density, color, thickness);
                    break;
                case 'contour':
                    drawContour(landmarks, color, thickness);
                    break;
                case 'irises':
                    drawIrises(landmarks, color, thickness);
                    break;
                case 'fun':
                    drawFunEffect(landmarks);
                    break;
                case 'none':
                    // 효과 없음 - 아무것도 그리지 않음
                    break;
            }
        }
        
        // 메시 그리기 함수
        function drawMesh(landmarks, density, color, thickness) {
            ctx.lineWidth = thickness;
            ctx.strokeStyle = color;
            ctx.fillStyle = color + '20'; // 약간 투명하게
            
            // 밀도에 따라 다른 연결점 사용
            let connections;
            if (density === 'sparse') {
                connections = FACEMESH_TESSELATION.filter((_, i) => i % 5 === 0);
            } else if (density === 'medium') {
                connections = FACEMESH_TESSELATION.filter((_, i) => i % 2 === 0);
            } else {
                connections = FACEMESH_TESSELATION;
            }
            
            // 점 연결선 그리기
            drawConnectors(ctx, landmarks, connections, {
                color: color,
                lineWidth: thickness
            });
            
            // 점 그리기
            for (const landmark of landmarks) {
                const x = landmark.x * outputCanvas.width;
                const y = landmark.y * outputCanvas.height;
                
                ctx.beginPath();
                ctx.arc(x, y, thickness * 0.8, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        // 윤곽선 그리기 함수
        function drawContour(landmarks, color, thickness) {
            ctx.lineWidth = thickness * 1.5;
            ctx.strokeStyle = color;
            
            // 얼굴 윤곽선
            drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, {
                color: color,
                lineWidth: thickness * 1.5
            });
            
            // 눈썹
            drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYEBROW, {
                color: color,
                lineWidth: thickness
            });
            drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYEBROW, {
                color: color,
                lineWidth: thickness
            });
            
            // 눈
            drawConnectors(ctx, landmarks, FACEMESH_LEFT_EYE, {
                color: color,
                lineWidth: thickness
            });
            drawConnectors(ctx, landmarks, FACEMESH_RIGHT_EYE, {
                color: color,
                lineWidth: thickness
            });
            
            // 입술
            drawConnectors(ctx, landmarks, FACEMESH_LIPS, {
                color: color,
                lineWidth: thickness
            });
        }
        
        // 홍채 그리기 함수
        function drawIrises(landmarks, color, thickness) {
            if (!landmarks[468] || !landmarks[473]) return;
            
            // 기본 색상
            const irisColor = '#ffffff';
            const pupilColor = '#000000';
            
            // 왼쪽 홍채
            const leftIris = landmarks[468];
            const lx = leftIris.x * outputCanvas.width;
            const ly = leftIris.y * outputCanvas.height;
            const lRadius = outputCanvas.width * 0.018;
            
            // 오른쪽 홍채
            const rightIris = landmarks[473];
            const rx = rightIris.x * outputCanvas.width;
            const ry = rightIris.y * outputCanvas.height;
            const rRadius = outputCanvas.width * 0.018;
            
            // 홍채 그리기
            ctx.beginPath();
            ctx.arc(lx, ly, lRadius, 0, 2 * Math.PI);
            ctx.fillStyle = irisColor;
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = thickness * 0.5;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(rx, ry, rRadius, 0, 2 * Math.PI);
            ctx.fillStyle = irisColor;
            ctx.fill();
            ctx.strokeStyle = color;
            ctx.lineWidth = thickness * 0.5;
            ctx.stroke();
            
            // 동공 그리기
            ctx.beginPath();
            ctx.arc(lx, ly, lRadius * 0.4, 0, 2 * Math.PI);
            ctx.fillStyle = pupilColor;
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(rx, ry, rRadius * 0.4, 0, 2 * Math.PI);
            ctx.fillStyle = pupilColor;
            ctx.fill();
            
            // 하이라이트 그리기
            ctx.beginPath();
            ctx.arc(lx - lRadius * 0.2, ly - lRadius * 0.2, lRadius * 0.1, 0, 2 * Math.PI);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(rx - rRadius * 0.2, ry - rRadius * 0.2, rRadius * 0.1, 0, 2 * Math.PI);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
        }
        
        // 재미 효과 그리기 함수
        function drawFunEffect(landmarks) {
            if (!landmarks) return;
            
            // 얼굴 윤곽선 그리기
            drawConnectors(ctx, landmarks, FACEMESH_FACE_OVAL, {
                color: 'rgba(255,255,255,0.8)',
                lineWidth: 3
            });
            
            // 다양한 색상의 입체적 메시
            const totalPoints = landmarks.length;
            for (let i = 0; i < totalPoints; i++) {
                const landmark = landmarks[i];
                const x = landmark.x * outputCanvas.width;
                const y = landmark.y * outputCanvas.height;
                const z = landmark.z;
                
                // 랜덤 색상 (얼굴의 각 부분에 따라 다른 색상 사용)
                const hue = (i / totalPoints * 360 + Date.now() / 100) % 360;
                const saturation = 70 + Math.sin(Date.now() / 1000) * 30;
                const lightness = 50 + Math.sin(Date.now() / 1500) * 10;
                
                ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                
                // z값에 따라 점 크기 조정
                const size = Math.max(1, 3 - z * 20);
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // 눈 위치 강조 효과
            if (landmarks[468] && landmarks[473]) {
                const leftEye = landmarks[468];
                const rightEye = landmarks[473];
                
                // 왼쪽 눈
                const lx = leftEye.x * outputCanvas.width;
                const ly = leftEye.y * outputCanvas.height;
                
                // 오른쪽 눈
                const rx = rightEye.x * outputCanvas.width;
                const ry = rightEye.y * outputCanvas.height;
                
                // 눈에 빛나는 효과
                const glowRadius = 20 + Math.sin(Date.now() / 500) * 5;
                
                // 왼쪽 눈 효과
                ctx.beginPath();
                const leftGradient = ctx.createRadialGradient(lx, ly, 0, lx, ly, glowRadius);
                leftGradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
                leftGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                ctx.fillStyle = leftGradient;
                ctx.arc(lx, ly, glowRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // 오른쪽 눈 효과
                ctx.beginPath();
                const rightGradient = ctx.createRadialGradient(rx, ry, 0, rx, ry, glowRadius);
                rightGradient.addColorStop(0, 'rgba(255, 0, 255, 0.8)');
                rightGradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                ctx.fillStyle = rightGradient;
                ctx.arc(rx, ry, glowRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 서비스 워커 등록
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                .then(registration => {
                    console.log('서비스 워커 등록 성공:', registration.scope);
                })
                .catch(error => {
                    console.log('서비스 워커 등록 실패:', error);
                });
            });
        }
    </script>
</body>
</html>